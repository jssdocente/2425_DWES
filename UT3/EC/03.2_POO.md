# 03.2 Ejercicios POO con PHP

Estos ejercicios est√°n pensados para que puedas practicar y afianzar los conocimientos adquiridos en el tema de POO.

### Entrega

Normas de entrega:

- Se guardar√°n dentro de la estructura de carpetas del tema `UT3`, carpeta ejercicios `EC`y `02`. En la ruta `UT3\EC\02\`.
- Cada ejericio se entregar√° en un archivo independiente, con el nombre que se indique en cada ejercicios.
- No es necesario entregarlos como tarea, pero si es necesario realizarlos, y se preguntar√°n aleatoriamente en clase.


### Ejercicios Bloque 2.

Los `Value Objets` son objetos que representan un valor, y no tienen identidad. Son inmutables, es decir, una vez creados no se pueden modificar. Son √∫tiles para encapsular valores y evitar errores en la manipulaci√≥n de datos. En lugar de pasar un valor primitivo, se pasa un objeto que representa ese valor, y la l√≥gica dentro del objeto se encarga de validar y manipular los datos.

La interfaz de una Value Object es simple, se construye a trav√©s del construtor, y tiene un m√©todo `value()` que devuelve el valor completo del objeto. Se implementa el m√©todo el m√©todo `__toString` para que devuelva el valor textual del objeto.

Para aplicar esta t√©cnica, vamos a crear una interfaz `IValueObject` que contenga un m√©todo `value()` y `__toString()`. 

```php	
interface IValueObject {
    public function value();
    public function __toString(): string;
}
```

Ahora todos los Value Objects que creemos deben implementar esta interfaz.

#### Ejercicio 201

nombre-fichero: `01.DniVO.php`

Crea un clase (*Value Object*) llamado `DniVO` que tenga los siguientes atributos: n√∫mero y letra. Adem√°s, tendr√° un m√©todo llamado `value()` que mostrar√° el DNI completo. El valor texto del DNI se pasar√° como par√°metro al constructor, y se dividir√° en n√∫mero y letra.
*Utiliza tipos (string, int, ...)*

- El atributo `numero` y `letra` ser√°n p√∫blicos y readonly (string).
- Tendr√° una funci√≥n `value()` que devolver√° el DNI completo (string).
- Agrega la funci√≥n `__toString` para que devuelva que retorne el valor de `value()`.
- Agrega la funci√≥n `calcularLetra` que devolver√° la letra correspondiente al n√∫mero del DNI y sea privada.
  ```php
   private function calcularLetra(string $dni): string {
        $letras = 'TRWAGMYFPDXBNJZSQVHLCKE';
        return $letras[(int)$dni % 23];
    }
  ```	

#### Ejercicio 202 (resuelto)

nombre-fichero: `02.AgeVO.php`

Crea una clase llamada `AgeVO` que reciba un par√°metro de tipo entero y tenga un atributo privado `value` que devuelva la edad. Si la edad es menor de 0 o mayor de 120, lanzar√° una excepci√≥n (en el constructor). El atributo `value` ser√° readonly. 
 ```php	
class AgeVO implements IValueObject {

    private int $value;
    
    public function __construct(int $value) {
        if ($value < 0 || $value > 120) {
            throw new Exception("Edad no v√°lida");
        }
        $this->value = $value;
    }
    public function value() : int {
        return $this->$name;
    }
 ```

#### Ejercicio 203

nombre-fichero: `03.HumanNameVO.php`

Crea una clase `HumanNameVO` que reciba 3 par√°metros de tipo string: nombre, primer apellido (default '') y segundo apellido (default ''). La clase tendr√° un m√©todo `value()` que devolver√° el nombre completo. Los atributos ser√°n readonly y privados
- Lanzar√° una excepci√≥n si cualquier de los valores es mayor de 50 caracteres.
- Implementa la interfaz `IValueObject` y el m√©todo `__toString` que devolver√° el valor de `value()`.


#### Ejercicio 204

nombre-fichero: `04.Persona.php`

Crea una clase llamada `Persona` que tenga los siguientes atributos: nombre (HumanNameVO), edad (AgeVO) y DNI (DniVO). Adem√°s, implementar√° el m√©todo `__toString` que devolver√° un string con los datos de la persona, en el siguiente formato:

 - Nombre completo, {edad} a√±os, 12345678Z

#### Ejercicio 205

nombre-fichero: `05.DivisaVO.php`

Crea un enum `DivisaEm` que tenga las siguientes constantes: EUR = "eur", USD="usd", GBP="gbp", JPY="jpy".
Esta enum tendr√° un m√©todo, para comprobar si 2 divisas son iguales, llamado `isEqual` que recibir√° 1 par√°metro `DivisaEm` y devolver√° un booleano.

Crea un Value Object llamado `DivisaVO` que implemente `IValueObject`, el atributo $value ser√° privado y readonly. El constructor recibir√° un par√°metro de tipo string y lo convertir√° a DivisamEm  (a trav√©s de tryFrom), en caso de error se asignar√° la Divisa "EUR". 
- Adem√°s tenga una atributo/propiedad `factor` que ser√° readonly y p√∫blico, que devolver√° el factor de conversi√≥n de la divisa. (Se construye como siempre por el constructor)
- El m√©todo `__toString` devolver√° el valor de la divisa. Ej: "EUR"
- El m√©todo `isEqual` que devolver√° si la divisa es igual a otra divisa pasada como par√°metro. Utiliza el m√©todo `isEqual` de la enum.
- El m√©todo `symbol` que devolver√° el s√≠mbolo de la divisa. Ej: "‚Ç¨"


#### Ejercicio 206 (resuelto)

nombre-fichero: `06.CurrecyVO.php`

Crea un Value Object `CurrencyVO` (implemente IValueObject) que tenga `amount` y `divisa` (DivisaVO) como propiedades, ambos read-only .El constructor recibir√° dos par√°metros, uno de tipo float y otro de tipo `DivisaVO`. Utiliza la caracter√≠stica de promoci√≥n de propiedades para asignar el valor de `amount` y `divisa` a los atributos correspondientes.


Tambi√©n debe permitir las siguientes operaciones:

- Un m√©todo `value()` que devolver√° el valor num√©rico de la divisa.
- Un m√©todo `__toString` que devolver√° el valor completo de la divisa. Ej "100EUR"
- Un m√©todo `convert` que permitir√° convertir la divisa a otra divisa. Recibir√° 2 par√°metros `(DivisaVO toDivisa, float factor=0)` y devolver√° un nuevo `CurrencyVO` con la cantidad convertida a la nueva divisa. Si la divisa de origen y destino son la misma, devolver√° el mismo objeto. Si el factor es 0, se utilizar√° el factor de la divisa, y si tambi√©n es 0, se lanzar√° una excepci√≥n.
- Un m√©todo `add` que permitir√° sumar una cantidad de dinero a la divisa. Solo permitir√° sumar divisas del mismo tipo.
  Se permiten sumar monedas o floats. Si es float, se convertir√° a CurrencyVO y posteriormente se sumar√°. 
- Un m√©todo `subtract` que permitir√° restar una cantidad de dinero a la divisa. Recibir√° un par√°metro de tipo `CurrencyVO` y devolver√° un nuevo `CurrencyVO` con la cantidad restada. Solo permitir√° restar divisas del mismo tipo.
 Se permiten restar monedas o floats. Si es float, se convertir√° a CurrencyVO y posteriormente se sumar√°. 

```php	
class CurrencyVO {

    public function __construct(
        public readonly float $amount,
        public readonly DivisaVO $divisa
    ) {}

    public function value(): float {
        return $this->amount;
    }

    public function __toString(): string {
        return $this->amount . ' ' . $this->divisa->value()->symbol();
    }

    public function add(CurrencyVO|float $value): CurrencyVO {
        if (is_float($value)) {
            $value = new CurrencyVO($value, $this->divisa);
        }

        if (!$this->divisa->isEqual($value->divisa))  {
            throw new Exception("No se permiten operaciones divisas diferentes");
        }
        return new CurrencyVO(round($this->amount + $value->amount,2), $this->divisa);
    }

    public function sub(CurrencyVO|float $value): CurrencyVO {
        if (is_float($value)) {
            $value = new CurrencyVO($value, $this->divisa);
        }

        if (!$this->divisa->isEqual($value->divisa))  {
            throw new Exception("No se permiten operaciones divisas diferentes");
        }
        return new CurrencyVO(round($this->amount - $value->amount,2), $this->divisa);
    }

    public function convert(DivisaVO $toDivisa, float $factor=0): CurrencyVO {
        if ($toDivisa->isEqual($this->divisa)) {
            return $this;
        }

        if ($factor==0) {
            $factor = $toDivisa->factor;
            if ($factor==0) {
                throw new Exception("Factor de conversi√≥n es 0.");
            }
        }

        $amount = $this->amount * $factor;
        return new CurrencyVO($amount, $toDivisa);
    }
}

```	

#### Ejercicio 207

nombre-fichero: `07.BankAccount.php`

Crea una clase llamada `BankAccount` que tenga los siguientes atributos: 

Propiedades:
- Titular (que es una persona), una divisa de trabajo, y un IBAN (Todos solo lectura y p√∫blicos).
- saldo (privada) que ser√° un `CurrencyVO`, y getSaldo() devolver√° el saldo de la cuenta.
  
Adem√°s, implementar√° los siguientes m√©todos:

- Un constructor que reciba los datos (utilizar√°n caracter√≠stica promoci√≥n de propiedades).
- Un m√©todo `retirar` que permitir√° sacar una cantidad de dinero (Moneda o float). Si la cantidad es negativa o mayor que la cantidad actual, lanzar√° una excepci√≥n.
- Un m√©todo `ingresar` que permitir√° ingresar una cantidad de dinero (Moneda o float). Si la cantidad es negativa, lanzar√° una excepci√≥n.
- Un m√©todo `__toString` que devolver√° un string con los datos de la cuenta, en el siguiente formato:
  - Titular: {nombre completo}, {edad} a√±os, {DNI} Saldo: {cantidad}{divisa}
  - 


#### Ejercicio 208

nombre-fichero: `08.BankDeposit.php`

Crea una clase `BankDeposit` que haga las funciones de un Banco de Dep√≥sitos. Esta clase tendr√°:

- El banco trabaja con solo una divisa, aunque podr√° hacer tranferencias entre distitas divisas. Tendr√° una propiedad que ser√° la divisa de trabajo. (divisa)
- El banco tendr√° un c√≥digo y un PAIS (constante ES)
- Un lista de las cuentas bancarias (BankAccount).
- Un m√©todo `addAccount` que permitir√° a√±adir una cuenta al banco.
  - Par√°metros: (Person $titular). La divisa ser√° la del banco. El IBAN se generar√° autom√°ticamente, en base al c√≥digo del banco y un n√∫mero aleatorio.
  - Retorna la cuenta creada.
- Un m√©todo `removeAccount` que permitir√° eliminar una cuenta del banco. (Para ello utiliza el IBAN y `array_filter`).	
- Un m√©todo `getAccount` que permitir√° obtener una cuenta a trav√©s de su IBAN. Si la cuenta no existe, retornar√° null.
- Un m√©todo `transfer` que permitir√° transferir una cantidad de dinero de una cuenta a otra. Si la divisa es diferente se deber√° convertir la divisa.
  - Si la cantidad es negativa o mayor que el saldo actual, lanzar√° una excepci√≥n indicando el tipo de error.
  - Si las 2 cuentas son iguales, lanzar√° una excepci√≥n.


Prueba la aplicaci√≥n a trav√©s de la siguiente p√°gina:
  
```php
$bankSantander = new DepositBank("Santander","2222");
$bankCaixa = new DepositBank("CaixaBank","7777");

$personA = new Person(
    new HumanNameVO('Jonh', 'Wilson'),
    new AgeVO(30),
    new DniVO('12345678')
);

$personB = new Person(
    new HumanNameVO('Jane', 'Doe'),
    new AgeVO(25),
    new DniVO('87654321')
);

$personC = new Person(
    new HumanNameVO('Javier', 'Mancera'),
    new AgeVO(45),
    new DniVO('34258536')
);

$bccA = $bankSantander->addAccount($personA);
$bccB = $bankSantander->addAccount($personB);
$bccC = $bankCaixa->addAccount($personC);

?>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<h5>Persona A abre Cuenta</h5>
<p><?= $bccA ?></p>
<h5>Persona B abre Cuenta</h5>
<p><?= $bccB ?></p>



<h5>Persona A ingresa 100 + 50 </h5>
<p><?php $bccA->ingresar(new CurrencyVO(100, new DivisaVO('EUR')));
    $bccA->ingresar(50); ?> Saldo: <?= $bccA->getSaldo() ?>
</p>
<h5>Persona B ingresa 250 + 50</h5>
<p><?php $bccB->ingresar(new CurrencyVO(200, new DivisaVO('EUR')));
    $bccB->ingresar(70); ?> Saldo: <?= $bccB->getSaldo() ?>
</p>
<h5>PersonaA transfiere +100EUR a PersonaB</h5>
<p><?php $bccA->transferir($bccB, 100); ?>
    CuentaA: <?= $bccA->getSaldo() ?> Cuenta B: <?= $bccB->getSaldo() ?></p>
<h5>PersonaB transfiere +50EUR a PersonaA</h5>
<p><?php $bccB->transferir($bccA, 50); ?>
    CuentaA: <?= $bccA->getSaldo() ?> Cuenta B: <?= $bccB->getSaldo() ?>
</p>

</body>
</html>
```


### üî• Refactorizar c√≥digo

Puede ser que en alg√∫n momento necesites introducir alg√∫n cambio en el c√≥digo (nuevo m√©todo, nuevo par√°metro en constructor, etc..) siente libre de hacerlo ya que tambi√©n es una parte del ejercicio.